---
sidebar_position: 2
---

# (Pre-)compiling code snippets

This configuration allows to extract code snippets and run them through your tool at build time, then insert the
output in the generated web site. As long as your tool can run in a GitHub Action container, this feature allows to easily
inline the output of your tool.

```js title="website/docusaurus.config.js"
...
const config = configure({ ... }, {
// highlight-start
    compileCode: {
        langs: [{
            lang: "...",
            ...
        }, ...]
    }
// highlight-end
})
```

### Tools published on npm

Let's take the TypeScript compiler as an example. First, start by adding `typescript` to your project

```bash npm2yarn
yarn add typescript
```

then add a `compileCode` language entry that will run all `ts` code section through the `tsc` node executable.

```js title="website/docusaurus.config.js"
compileCode: {
    langs: [
        // highlight-start
        {
            lang: "ts",
            nodeBin: "tsc",
        },
        // highlight-end
    ];
}
```

Let's take a look at this example in action.

````markdown
    ```ts showLineNumbers ignoreErrors
    console.llog("typo!")
    ```
````

When rendered in the docs, this snippet looks like any other code snippet. But you'll also notice an additional box
underneath with the TypeScript compiler output. This output was computed at build time.

```ts showLineNumbers ignoreErrors
console.llog("typo!");
```

### node.js script

A `command` parameter ending in `.js` or `.mjs` will automatically
be executed through node.js. 
Each snippet will be run in its individual process.

The example below execute the [Z3](https://github.com/Z3Prover/z3) constraint solver.

```js
    {
        lang: "z3wasm",
        extension: "z3",
        inputLang: "lisp",
        command: "./langs/z3.mjs",
    },
```

where `z3.mjs` is a node script that reads `input.z3`, `options.json` from the current working directory,
executes Z3 and prints the result to the console.

````markdown
```z3asm
(declare-const a Int)
(declare-fun f (Int Bool) Int)
(assert (< a 10))
(assert (< (f a true) 100))
(check-sat)
```
````

And now rendered...

```z3wasm
(declare-const a Int)
(declare-fun f (Int Bool) Int)
(assert (< a 10))
(assert (< (f a true) 100))
(check-sat)
```

## Custom tool

To support custom scenario, you can provide a `compile` function
and wire it up as you please.

In this example, we create a `echo` tool that copies the capitalized input source
into the output.

```js title="website/docusaurus.config.js"
    compileCode: {
        langs: [
        ...,
// highlight-start
        {
            lang: "echo",
            compile: async (source, langOptions) => ({
                code: 0,
                stdout: source.toUppercase(),
            }),
        }
// highlight-end
    ]}
```

Let's take a look at this example in action.

````markdown
```echo
hello
```
````

When rendered in the docs, this snippet looks like any other code snippe.
But you'll also notice an additional box
underneath with the capitalized text.

```echo
hello
```

## Tool configuration flags

### `langMeta`

An additional meta filter for selecting snippet. If this field is preset, snippet without the meta (case sensitive) 
will be ignored.

```js title="website/docusaurus.config.js"
    ...
    {
        lang: "ts",
        langMeta: "check",
    },
```

````markdown
```ts check
let x = 0
```
````

### `inputLang`

After processing the source, replace the `lang` value 
with `inputLang`, so that it gets syntax colored with that language.

## pre-snippet configuration meta

The following meta tags can be used to customize the behavior of each snippet.

### `skip`

Completely ignore snippet.

````markdown
```echo skip
just ignore me
```
````

### `ignore-errors`

Don't fail the rendering step if errors occur.

````markdown
```ts ignore-errors
console.lllllog("yup, there's a typo")
```
````
